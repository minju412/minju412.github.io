---
title:  "[BOJ] 2531 - 회전 초밥 (🥈 실버 1티어, 슬라이딩 윈도우 알고리즘 🌟) "
# excerpt: "sprintf에 대해 알아보자"

categories:
  - CodingTest
tags:
  - [CodingTest]

toc: true
toc_sticky: true
 
date: 2023-07-08 11:41:14
last_modified_at: 2023-07-08 11:41:16
---

사용 언어: Python3, Java

## 문제
> [회전 초밥](https://www.acmicpc.net/problem/2531)

## 풀이
### 나의 풀이
```py
# 접시수, 초밥 가짓수, 연속해서 먹는 접시수, 쿠폰번호
N, d, k, c = map(int, input().split())
lst = [int(input()) for _ in range(N)]

sushi_kind_cnt = [] # 초밥 종류수
for i in range(N):
    lp = i
    rp = (lp + (k-1)) % N
    tmp = [] # 벨트의 임의의 한 위치부터 연속된 k개의 초밥
    for i in range(lp, rp + 1):
        tmp.append(lst[i])
    sushi_kind_cnt.append(len(set(tmp+[c])))

print(max(sushi_kind_cnt))
```
- 테스트 케이스: 성공
- 제출 결과: 시간초과


### 다른 풀이
>[참고](https://wooono.tistory.com/654)

```py
import sys
from collections import defaultdict
input = sys.stdin.readline

# n : 회전 초밥 벨트에 놓인 접시의 수
# d : 초밥의 가짓수
# k : 연속해서 먹는 접시의 수
# c : 쿠폰 번호
n, d, k, c = map(int, input().rstrip().split())
lst = list(int(input().rstrip()) for _ in range(n)) # 초밥 접시들

# 구간 인덱스 초기화
lp, rp = 0, k-1

# 구간 내의 접시 종류별 개수
dict = defaultdict(int)

# 구간 내에는 항상 쿠폰 번호가 포함되어있다고 가정
dict[c] += 1

# 첫 시작 구간의 접시 종류별 개수 저장
for i in range(rp + 1):
    dict[lst[i]] += 1

mx = -1e9 # 구간 내의 최대 접시 종류 개수 초기화
# 슬라이딩 윈도우 진행
while lp < n:
    mx = max(mx, len(dict)) # 종류의 최댓값 갱신
    # 윈도우를 오른쪽으로 한 칸씩 이동하기 위한 작업 진행
    dict[lst[lp]] -= 1 # 현재 구간 내의 가장 왼쪽 접시를 제거
    if (dict[lst[lp]] == 0): # 이제 해당 종류의 접시가 남아있지 않다면, 딕셔너리에서 제거
        del dict[lst[lp]]
    lp += 1 # 왼쪽 인덱스를 오른쪽으로 한 칸 이동
    rp += 1 # 오른쪽 인덱스를 오른쪽으로 한 칸 이동
    dict[lst[rp % n]] += 1 # 현재 구간 내의 가장 오른쪽 접시를 추가

# 결과 출력
print(mx)
```
- 테스트 케이스: 성공
- 제출 결과: 성공
- 슬라이딩 윈도우 알고리즘에 대해 궁금하다면 [이 글](https://soeasyalgo.tistory.com/49)을 참고하자!







***
<br>


    💛 개인 공부 기록용 블로그입니다. 👻

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}