---
title:  "[SPRING] 검증 - 1. Validation "

categories:
  - Spring
tags:
  - [Framework, Spring, Java]

toc: true
toc_sticky: true
 
date: 2022-06-30 18:08:10
last_modified_at: 2022-06-30 18:08:13
---

# 검증 요구사항
상품 관리 시스템에 새로운 요구사항이 추가되었다.

- 타입 검증<br>- 가격, 수량에 문자가 들어가면 검증 오류 처리 
- 필드 검증<br>- 상품명: 필수, 공백X<br>- 가격: 1000원 이상, 1백만원 이하 <br>- 수량: 최대 9999
- 특정 필드의 범위를 넘어서는 검증<br>- 가격 * 수량의 합은 10,000원 이상

지금까지 만든 웹 애플리케이션은 폼 입력시 숫자를 문자로 작성하거나해서 검증 오류가 발생하면 오류 화면으로 바로 이동한다. <br>
웹 서비스는 폼 입력시 오류가 발생하면, 고객이 입력한 데이터를 유지한 상태로 어떤 오류가 발생했는지 친절하게 알려주어야 한다.<br><br>
컨트롤러의 중요한 역할중 하나는 HTTP 요청이 정상인지 검증하는 것이다. <br>
그리고 정상 로직보다 이런 검증 로직을 잘 개발하는 것이 어쩌면 더 어려울 수 있다.

> 참고: 클라이언트 검증, 서버 검증<br>
- 클라이언트 검증은 조작할 수 있으므로 보안에 취약하다.
- 서버만으로 검증하면, 즉각적인 고객 사용성이 부족해진다.
- 둘을 적절히 섞어서 사용하되, 최종적으로 서버 검증은 필수
- API 방식을 사용하면 API 스펙을 잘 정의해서 검증 오류를 API 응답 결과에 잘 남겨주어야 함

먼저 검증을 직접 구현해보고, 뒤에서 스프링과 타임리프가 제공하는 검증 기능을 활용해보자.

# V1 - 검증 직접 처리
이전 프로젝트에 이어서 검증(Validation) 기능을 학습해보자.
## 소개
### 상품 저장 성공
![스크린샷 2022-06-30 오후 6 52 39](https://user-images.githubusercontent.com/59405576/176648413-f8df184e-2d92-499d-a348-04e281de5bd3.png)<br>
사용자가 상품 등록 폼에서 정상 범위의 데이터를 입력하면, 서버에서는 검증 로직이 통과하고, 상품을 저장하고, 상품 상세 화면으로 redirect한다.

### 상품 저장 실패
![스크린샷 2022-06-30 오후 6 52 57](https://user-images.githubusercontent.com/59405576/176648495-376e8b8f-1fc6-489d-bad1-6ca0b4537e87.png)<br>
고객이 상품 등록 폼에서 상품명을 입력하지 않거나, 가격, 수량 등이 너무 작거나 커서 검증 범위를 넘어서면, 서버 검증 로직이 실패해야 한다. <br>
이렇게 검증에 실패한 경우 고객에게 다시 상품 등록 폼을 보여주고, 어떤 값을 잘못 입력했는지 친절하게 알려주어야 한다.<br><br>
이제 요구사항에 맞추어 검증 로직을 직접 개발해보자.

## 개발
### ☂️ 상품 등록 검증
#### 컨트롤러 - `ValidationItemControllerV1`
`addItem()`을 수정한다.
```java
@Slf4j
@Controller
@RequestMapping("/validation/v1/items")
@RequiredArgsConstructor
public class ValidationItemControllerV1 {
...
  @PostMapping("/add")
    public String addItem(@ModelAttribute Item item, RedirectAttributes redirectAttributes, Model model) {

      // 1) 검증 오류 결과를 보관
      Map<String, String> errors = new HashMap<>();

      // 2) 검증 로직
      if (!StringUtils.hasText(item.getItemName())){
          errors.put("itemName", "상품 이름은 필수입니다.");
      }
      if (item.getPrice()==null || item.getPrice()<1000 || item.getPrice()>1000000){
          errors.put("price", "가격은 1,000 ~ 1,000,000 까지 허용합니다.");
      }
      if (item.getQuantity()==null || item.getQuantity()>=9999){
          errors.put("quantity", "수량은 최대 9,999 까지 허용합니다.");
      }

      // 3) 특정 필드가 아닌 복합 룰 검증
      if (item.getPrice()!=null && item.getQuantity()!=null){
          int resultPrice = item.getPrice() * item.getQuantity();
          if (resultPrice<10000){
              errors.put("globalError", "가격 * 수량의 합은 10,000원 이상이어야 합니다. 현재 값 = " + resultPrice);
          }
      }

      // 4) 검증에 실패하면 다시 입력 폼으로
      if (!errors.isEmpty()){
          log.info("errors = {}", errors);

          model.addAttribute("errors", errors);
          return "validation/v1/addForm";
      }

      // 성공 로직
      Item savedItem = itemRepository.save(item);
      redirectAttributes.addAttribute("itemId", savedItem.getId());
      redirectAttributes.addAttribute("status", true);
      return "redirect:/validation/v1/items/{itemId}";
  }
...
}
```

##### 1) 검증 오류 보관
`Map<String, String> errors = new HashMap<>();`<br>
만약 검증시 오류가 발생하면 어떤 검증에서 오류가 발생했는지 정보를 담아둔다.

##### 2) 검증 로직
```java
 if (!StringUtils.hasText(item.getItemName())) { 
  errors.put("itemName", "상품 이름은 필수입니다.");
}
```
📍 `import org.springframework.util.StringUtils;` 추가 필요<br><br>
검증시 오류가 발생하면 `errors` 에 담아둔다. <br>
이때 어떤 필드에서 오류가 발생했는지 구분하기 위해 오류가 발생한 필드명을 `key` 로 사용한다. <br>
이후 뷰에서 이 데이터를 사용해서 고객에게 친절한 오류 메시지를 출력할 수 있다.


##### 3) 특정 필드의 범위를 넘어서는 검증 로직
특정 필드를 넘어서는 오류를 처리해야 할 수도 있다. <br>
이때는 필드 이름을 넣을 수 없으므로 `globalError` 라는 `key` 를 사용하였다.

##### 4) 검증에 실패하면 다시 입력 폼으로
만약 검증에서 오류 메시지가 하나라도 있으면 오류 메시지를 출력하기 위해 `model`에 `errors` 를 담고, 입력 폼이 있는 뷰 템플릿으로 보낸다.

#### 뷰 - `addForm.html`
`validation/v1/addForm.html` 수정
```html
...
<style>
      .container {
          max-width: 560px;
      }
      .field-error {
          border-color: #dc3545;
          color: #dc3545;
      }
</style>
...
<form action="item.html" th:action th:object="${item}" method="post">

      <div th:if="${errors?.containsKey('globalError')}">
          <p class="field-error" th:text="${errors['globalError']}">전체 오류 메시지</p>
      </div>

      <div>
          <label for="itemName" th:text="#{label.item.itemName}">상품명</label>
          <input type="text" id="itemName" th:field="*{itemName}"
                  th:class="${errors?.containsKey('itemName')} ? 'form-control field-error' : 'form-control'"
                  class="form-control"
                  placeholder="이름을 입력하세요">
          <div class="field-error" th:if="${errors?.containsKey('itemName')}" th:text="${errors['itemName']}">
              상품명 오류
          </div>
      </div>
      <div>
          <label for="price" th:text="#{label.item.price}">가격</label>
          <input type="text" id="price" th:field="*{price}"
                  th:classappend="${errors?.containsKey('price')} ? 'field-error' : _"
                  class="form-control"
                  placeholder="가격을 입력하세요">
          <div class="field-error" th:if="${errors?.containsKey('price')}" th:text="${errors['price']}">
              가격 오류
          </div>
      </div>
      <div>
          <label for="quantity" th:text="#{label.item.quantity}">수량</label>
          <input type="text" id="quantity" th:field="*{quantity}" class="form-control"
                  th:classappend="${errors?.containsKey('quantity')} ? 'field-error' : _"
                  placeholder="수량을 입력하세요">
          <div class="field-error" th:if="${errors?.containsKey('quantity')}" th:text="${errors['quantity']}">
              수량 오류
          </div>
      </div>

      <hr class="my-4">
...
```
##### css 추가
이 부분은 오류 메시지를 빨간색으로 강조하기 위해 추가했다.

##### 전체 오류 메시지
오류 메시지는 `errors` 에 내용이 있을 때만 출력하면 된다. <br>
타임리프의 `th:if` 를 사용하면 조건에 만족할 때만 해당 HTML 태그를 출력할 수 있다.

> 💡 참고 - Safe Navigation Operator (`?.`)<br>
만약 여기에서 `errors` 가 `null` 이라면 어떻게 될까? 생각해보면 등록폼에 진입한 시점에는 `errors` 가 없다.<br>
따라서 `errors.containsKey()` 를 호출하는 순간 `NullPointerException` 이 발생한다.<br><br>
`errors?.` 은 `errors` 가 `null` 일때 `NullPointerException` 이 발생하는 대신, `null` 을 반환하는 문법이다.<br>
`th:if` 에서 `null` 은 실패로 처리되므로 오류 메시지가 출력되지 않는다.<br>
이것은 스프링의 SpringEL이 제공하는 문법이다. 

##### 필드 오류 처리 - `th:classappend`
- `th:class="${errors?.containsKey('itemName')} ? 'form-control field-error' : 'form-control'"`
- `th:classappend="${errors?.containsKey('itemName')} ? 'field-error' : _"` 🌟

위의 두 코드는 같은 의미이다. `th:class`를 사용할 때보다 `th:classappend` 를 사용하면 더 깔끔하게 코드를 구성할 수 있다.<br><br>
`classappend` 를 사용해서 해당 필드에 오류가 있으면 `field-error` 라는 클래스 정보를 더해서 폼의 색깔을 빨간색으로 강조한다. <br>
만약 값이 없으면 `_` (No-Operation)을 사용해서 아무것도 하지 않는다.

#### 정리
- 만약 검증 오류가 발생하면 입력 폼을 다시 보여준다.
- 검증 오류들을 고객에게 친절하게 안내해서 다시 입력할 수 있게 한다. 
- 검증 오류가 발생해도 고객이 입력한 데이터가 유지된다.

지금까지는 상품 등록의 검증을 살펴봤다.<br>
상품 수정의 검증은 더 효율적인 검증 처리 방법을 학습한 다음에 진행한다.

##### 남은 문제점
- 뷰 템플릿에서 중복 처리가 많다. 뭔가 비슷하다.
- 타입 오류 처리가 안된다. <br>
`Item` 의 `price` , `quantity` 같은 숫자 필드는 타입이 `Integer` 이므로 문자 타입으로 설정하는 것이 불가능하다. <br>
숫자 타입에 문자가 들어오면 오류가 발생한다. 그런데 이러한 오류는 스프링MVC에서 컨트롤러에 진입하기도 전에 예외가 발생하기 때문에, 컨트롤러가 호출되지도 않고, 400 예외가 발생하면서 오류 페이지를 띄워준다.
- `Item`의 `price`에 문자를 입력하는 것처럼 타입 오류가 발생해도 고객이 입력한 문자를 화면에 남겨야 한다. <br>
만약 컨트롤러가 호출된다고 가정해도 `Item` 의 `price` 는 `Integer` 이므로 문자를 보관할 수가 없다. <br>
결국 문자는 바인딩이 불가능하므로 고객이 입력한 문자가 사라지게 되고, 고객은 본인이 어떤 내용을 입력해서 오류가 발생했는지 이해하기 어렵다.
- 결국 고객이 입력한 값도 어딘가에 별도로 관리가 되어야 한다.

# V2 - 스프링 제공
지금부터 스프링이 제공하는 검증 오류 처리 방법을 하나씩 알아보자. 여기서 핵심은 BindingResult이다. 우선 코드로 확인해보자.

## BindingResult 1

### 컨트롤러 - `ValidationItemControllerV2`
`addItem()`을 수정한다.
```java
@Slf4j
@Controller
@RequestMapping("/validation/v2/items")
@RequiredArgsConstructor
public class ValidationItemControllerV2 {
...
  @PostMapping("/add")
  public String addItem(@ModelAttribute Item item, BindingResult bindingResult, RedirectAttributes redirectAttributes, Model model) {

      // 검증 로직
      if (!StringUtils.hasText(item.getItemName())){
          bindingResult.addError(new FieldError("item","itemName", "상품 이름은 필수입니다."));
      }
      if (item.getPrice()==null || item.getPrice()<1000 || item.getPrice()>1000000){
          bindingResult.addError(new FieldError("item","price", "가격은 1,000 ~ 1,000,000 까지 허용합니다."));
      }
      if (item.getQuantity()==null || item.getQuantity()>=9999){
          bindingResult.addError(new FieldError("item","quantity", "수량은 최대 9,999 까지 허용합니다."));
      }

      // 특정 필드가 아닌 복합 룰 검증
      if (item.getPrice()!=null && item.getQuantity()!=null){
          int resultPrice = item.getPrice() * item.getQuantity();
          if (resultPrice<10000){
              bindingResult.addError(new ObjectError("item", "가격 * 수량의 합은 10,000원 이상이어야 합니다. 현재 값 = " + resultPrice));
          }
      }

      // 검증에 실패하면 다시 입력 폼으로
      if (bindingResult.hasErrors()){
          log.info("errors={}", bindingResult);
          return "validation/v2/addForm";
      }

      // 성공 로직
      Item savedItem = itemRepository.save(item);
      redirectAttributes.addAttribute("itemId", savedItem.getId());
      redirectAttributes.addAttribute("status", true);
      return "redirect:/validation/v2/items/{itemId}";
  }
...
}
```

> 주의 🚨<br>
`BindingResult bindingResult` 파라미터의 위치는 `@ModelAttribute Item item` 다음에 와야 한다.

- 이전 코드와의 차이점
![스크린샷 2022-06-30 오후 11 03 51](https://user-images.githubusercontent.com/59405576/176697529-c19ef1ed-68d1-4c12-a187-cdd4e0534989.png)

#### 필드 오류 - `FieldError` 
```java
if (!StringUtils.hasText(item.getItemName())){
    bindingResult.addError(new FieldError("item","itemName", "상품 이름은 필수입니다."));
}
```
- `FieldError` 생성자 - `public FieldError(String objectName, String field, String defaultMessage) {}`<br>
• `objectName` : `@ModelAttribute` 이름<br>
• `field` : 오류가 발생한 필드 이름<br>
• `defaultMessage` : 오류 기본 메시지

필드에 오류가 있으면 `FieldError` 객체를 생성해서 `bindingResult` 에 담아두면 된다. 


#### 글로벌 오류 - `ObjectError` 
```java
if (item.getPrice()!=null && item.getQuantity()!=null){
    int resultPrice = item.getPrice() * item.getQuantity();
    if (resultPrice<10000){
        bindingResult.addError(new ObjectError("item", "가격 * 수량의 합은 10,000원 이상이어야 합니다. 현재 값 = " + resultPrice));
    }
}
```
- `ObjectError` 생성자 - `public ObjectError(String objectName, String defaultMessage) {}`<br>
• `objectName` : `@ModelAttribute` 의 이름<br>
• `defaultMessage` : 오류 기본 메시지

특정 필드를 넘어서는 오류가 있으면 `ObjectError` 객체를 생성해서 `bindingResult` 에 담아두면 된다. 

### 뷰 - `addForm.html`
`validation/v2/addForm.html` 수정
```html
...
<div class="py-5 text-center">
        <h2 th:text="#{page.addItem}">상품 등록</h2>
    </div>

    <form action="item.html" th:action th:object="${item}" method="post">

        <div th:if="${#fields.hasGlobalErrors()}">
            <p class="field-error" th:each="err : ${#fields.globalErrors()}" th:text="${err}">글로벌 오류 메시지</p>
        </div>

        <div>
            <label for="itemName" th:text="#{label.item.itemName}">상품명</label>
            <input type="text" id="itemName" th:field="*{itemName}"
                   th:errorclass="field-error" class="form-control"
                   placeholder="이름을 입력하세요">
            <div class="field-error" th:errors="*{itemName}">
                상품명 오류
            </div>
        </div>
        <div>
            <label for="price" th:text="#{label.item.price}">가격</label>
            <input type="text" id="price" th:field="*{price}"
                   th:errorclass="field-error" class="form-control"
                   placeholder="가격을 입력하세요">
            <div class="field-error" th:errors="*{price}">
                가격 오류
            </div>
        </div>
        <div>
            <label for="quantity" th:text="#{label.item.quantity}">수량</label>
            <input type="text" id="quantity" th:field="*{quantity}"
                   th:errorclass="field-error" class="form-control"
                   placeholder="수량을 입력하세요">
            <div class="field-error" th:errors="*{quantity}">
                수량 오류
            </div>
        </div>

        <hr class="my-4">
...
```

- 이전 코드와의 차이점
![스크린샷 2022-06-30 오후 11 04 11](https://user-images.githubusercontent.com/59405576/176697603-0da17507-36ae-4fa9-9323-8566442ddd10.png)

#### 필드 오류
```html
<div>
    <label for="itemName" th:text="#{label.item.itemName}">상품명</label>
    <input type="text" id="itemName" th:field="*{itemName}"
            th:errorclass="field-error" class="form-control"
            placeholder="이름을 입력하세요">
    <div class="field-error" th:errors="*{itemName}">
        상품명 오류
    </div>
</div>
```
- `th:errors` : 해당 필드에 오류가 있는 경우에 태그를 출력한다. `th:if` 의 편의 버전이다. 
- `th:errorclass` : `th:field` 에서 지정한 필드에 오류가 있으면 `class` 정보를 추가한다.

#### 글로벌 오류 
```html
<div th:if="${#fields.hasGlobalErrors()}">
    <p class="field-error" th:each="err : ${#fields.globalErrors()}" th:text="${err}">글로벌 오류 메시지</p>
</div>
```
- `#fields` :` #fields` 로 `BindingResult` 가 제공하는 검증 오류에 접근할 수 있다.

### 검증과 오류 메시지 공식 메뉴얼
[https://www.thymeleaf.org/doc/tutorials/3.0/thymeleafspring.html#validation-and-error-messages](https://www.thymeleaf.org/doc/tutorials/3.0/thymeleafspring.html#validation-and-error-messages)

## BindingResult 2
- 스프링이 제공하는 검증 오류를 보관하는 객체이다. 검증 오류가 발생하면 여기에 보관하면 된다. 
- `BindingResult` 가 있으면 `@ModelAttribute` 에 데이터 바인딩 시 오류가 발생해도 컨트롤러가 호출된다!
- 예) `@ModelAttribute`에 바인딩 시 타입 오류가 발생하면?<br>
• `BindingResult` 가 없으면 400 오류가 발생하면서 컨트롤러가 호출되지 않고, 오류 페이지로 이동한다.<br>
• `BindingResult` 가 있으면 오류 정보( `FieldError` )를 `BindingResult` 에 담아서 컨트롤러를 정상 호출한다.

> 주의 🚨
- `BindingResult` 는 검증할 대상 바로 다음에 와야한다. 순서가 중요하다. <br>
예를 들어서 `@ModelAttribute Item item` , 바로 다음에 `BindingResult` 가 와야 한다.
- `BindingResult` 는 `Model에` 자동으로 포함된다.

### BindingResult에 검증 오류를 적용하는 3가지 방법
1. `@ModelAttribute` 의 객체에 타입 오류 등으로 바인딩이 실패하는 경우 스프링이 `FieldError` 생성해서 `BindingResult` 에 넣어준다.
2. 개발자가 직접 넣어준다.
3. `Validator` 사용 -> 이것은 뒤에서 설명

### 정리
`BindingResult` , `FieldError` , `ObjectError` 를 사용해서 오류 메시지를 처리하는 방법을 알아보았다. <br>
그런데 오류가 발생하는 경우 고객이 입력한 내용이 모두 사라진다. <br>
다음 글에서 이 문제를 해결해보자.





***
<br>

    💛 개인 공부 기록용 블로그입니다. 👻

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}