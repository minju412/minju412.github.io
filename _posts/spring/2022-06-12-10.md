---
title:  "[SPRING] HTTP 상태코드"

categories:
  - Spring
tags:
  - [Framework, Spring, Java]

toc: true
toc_sticky: true
 
date: 2022-06-12 20:59:27
last_modified_at: 2022-06-12 20:59:31
---
# 상태코드
클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능
- 1xx (Informational): 요청이 수신되어 치리중 (거의 사용되지 않음)
- 2xx (Successful): 요청 정상 처리
- 3xx (Redirection): 요청을 완료하려면 추가 행동이 필요
- 4xx (Client Error): 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음
- 5xx (Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함

# 2xx - 성공
## 200 OK
클라이언트의 요청 성공

## 201 Created
클라이언트의 요청으로 서버쪽에서 무언가 새로운 리소스를 생성 (주로 POST로 등록한 경우)<br>
생성된 리소스는 응답(res)의 Location 헤더 필드로 식별

## 202 Accepted
요청이 접수되었으나 처리가 완료되지 않았음
- 배치 처리 같은 곳에서 사용
- 예) 요청 접수 후 1시간 뒤에 배치 프로세스가 요청을 처리함

## 204 No Content
서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음
- 예) 웹 문서 편집기에서 save(저장) 버튼에서 사용
- save 버튼의 결과로 아무 내용이 없어도 된다.
- save 버튼을 눌러도 같은 화면을 유지해야 한다.
- 결과 내용이 없어도 204 메시지(2xx)만으로 성공을 인식할 수 있다.

# 3xx - 리다이렉션
요청을 완료하기 위해 유저 에이전트(클라이언트의 프로그램: 주로 웹 브라우저)의 추가 조치 필요

<!-- ## 300 Multiple Choices
거의 사용하지 않음

## 301 Moved Permanently -->
## 리다이렉션의 이해
웹 브라우저는 3xx 응답 결과에 Location 헤더가 있으면, Location 위치로 자동 이동 (=리다이렉트)<br>
![스크린샷 2022-06-12 오후 9 27 35](https://user-images.githubusercontent.com/59405576/173233177-fb40afe2-5bf9-4913-93f6-0fbdb266c5aa.png)<br>
경로가 영원히 이동한 경우 301코드를 반환하며 Location에 새로운 경로를 반환한다.<br>
클라이언트에서는 3xx 코드에 Location 헤더 필더가 존재한다면 자돋으로 새로운 경로로 리다이렉트 한다.<br>
## 리다이렉션의 종류
### 1. 영구 리다이렉션 
- 특정 리소스의 URI가 영구적으로 이동
- 원래의 URL을 사용하지 않음, 검색 엔진 등에서도 변경 인지
- 예) /members -> /users
- 예) /event -> /new-event

#### 301 Moved Permanently
![스크린샷 2022-06-12 오후 10 20 47](https://user-images.githubusercontent.com/59405576/173235237-3476a1de-b3e2-4a1c-b79e-5957034e04a0.png)
- 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음(MAY)
- 실무에서는 308보다는 301을 사용

#### 308 Permanent Redirect
![스크린샷 2022-06-12 오후 10 20 57](https://user-images.githubusercontent.com/59405576/173235241-612fe90a-ff8f-41a1-9d24-4c4d0743528b.png)
- 301과 기능은 같음
- 리다이렉트시 요청 메서드와 본문 유지<br>(처음 POST를 보내면 리다이렉트도 POST 유지)

### 2. 일시 리다이렉션 🌟
- 리소스의 URI 가 일시적으로 변경 
- 따라서 검색 엔진 등에서 URL을 변경하면 안됨
- 주문 완료 후 주문 내역 화면으로 이동
- PRG: Post/Redirect/Get (아래에서 다시 설명한다.)

#### 302 Found
- 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음(MAY)
- 실무에서 많이 사용

#### 307 Temporary Redirect
- 302와 기능은 같음
- 리다이렉트 요청 메서드와 본문을 유지해야 함<br>(요청 메서드를 변경하면 안된다. MUST NOT)

#### 303 See Other
- 302와 기능은 같음
- 307과 달리 리다이렉트시 요청 메서드가 GET으로 변경

#### 일시 리다이렉션 정리 
##### 뭘 써야하나요?
- 302 Found -> GET으로 변할 수 있음 (거의 GET으로 변한다.)
- 307 Temporary Redirect -> 메서드가 변하면 안됨
- 303 See Other -> 메서드가 GET으로 변경 되어야 함

##### 역사
- 처음 302 스펙의 의도는 HTTP 메서드를 유지하는 것
- 그런데 웹 브라우저들이 대부분 GET으로 바꾸어버림 (일부는 다르게 동작)
- 그래서 모호한 302를 대신하는 명확한 307, 303이 등장함 (301 대응으로 308도 등장)

##### 현실
- 307, 303을 권장하지만 현실적으로 이미 많은 애플리케이션 라이브러리들이 302를 기본값으로 사용
- 자동 리다이렉션 시에 GET으로 변해도 되면 그냥 302를 사용해도 큰 문제 없음

### 3. 특수 리다이렉션
- 결과 대신 캐시를 사용
- 300 Multiple Choices는 사용하지 않는다.

#### 304 Not Modified 🌟
- 캐시를 목적으로 사용
- 클라이언트에게 리소스가 수정되지 않았음을 알려준다.<br>따라서 클라이언트는 로컬 PC에 저장된 캐시를 재사용한다. (캐시로 리다이렉트 한다.)
- 304 응답은 응답에 메시지 바디를 포함하면 안된다. (로컬 캐시를 사용해야 하므로)
- 조건시 GET, HEAD 요청 시 사용

## PRG: Post/Redirect/Get 🌟
### 문제 상황
![스크린샷 2022-06-12 오후 10 42 31](https://user-images.githubusercontent.com/59405576/173236114-d1fa9d29-8109-400b-919e-29018a172971.png)<br>
POST로 주문 후에 웹 브라우저를 새로고침하면? -> 새로고침은 다시 요청 -> 중복 주문이 될 수 있다!

### 문제 해결
POST로 주문 후에 새로 고침으로 인한 중복 주문을 방지하기 위해 아래와 같이 할 수 있다.
- POST로 주문 후에 주문 결과 화면을 GET 메서드로 리다이렉트
- 새로고침해도 결과 화면을 GET으로 조회
- 중복 주문 대신에 결과 화면만 GET으로 다시 요청

### 예시
![스크린샷 2022-06-12 오후 10 43 35](https://user-images.githubusercontent.com/59405576/173236152-2ba6fc79-e5ca-4465-89be-c0b909933af5.png)<br>
1. 클라이언트가 상품을 요청한다.
2. 서버는 클라이언트의 주문 데이터를 db에 저장한 뒤, ('200 OK'가 아닌) 302 Found 혹은 303 See Other와 Location으로 응답한다.
3. 클라이언트는 상태코드 3xx과 Location 헤더를 확인한 뒤, POST를 GET으로 바꿔서 자동 리다이렉트한다.
4. 이후에는 새로고침해도 GET 메서드이기 때문에 중복 결제 등의 문제가 발생하지 않는다.

> PRG 이후 리다이렉트
- URL이 이미 POST -> GET으로 리다이렉트 됨
- 새로고침 해도 GET으로 결과 화면만 조회


# 4xx - 클라이언트 오류
- 클라이언트의 요청에 잘못된 문법 등으로 서버가 요청을 수행할 수 없음
- 오류의 원인이 클라이언트에 있음
- 중요! 클라이언트가 이미 잘못된 요청 혹은 데이터를 보내고 있기 때문에 똑같은 재시도가 실패함 🌟

## 400 Bad Request
클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음
- 요청 구문, 메시지 등등 오류
- 클라이언트는 요청 내용을 다시 검토하고 보내야 함
- 예) 요청 파라미터가 잘못되거나, API 스펙이 맞지 않을 때

## 401 Unauthorized
클라이언트가 해당 리소스에 대한 인증이 필요함
- 인증(Authentication) 되지 않음
- 401 오류 발생 시 응답에 WWW-Authenticate 헤더와 함께 인증 방법을 설명

> 참고
- 인증(Authentication): 본인이 누구인지 확인, (로그인)
- 인가(Authorization): 권한 부여<br>(ADMIN 권한처럼 특정 리소스에 접근할 수 있는 권한, 인증이 있어야 인가가 있음)
- 오류 메시지가 Unauthorized이지만 인증이 되지 않은 것! (이름이 아쉬움..)

## 403 Forbidden
서버가 요청을 이해했지만 승인을 거부함
- 주로 인증 자격 증명은 있지만, 접근 권한이 불충분한 경우
- 예) ADMIN 등급이 아닌 사용자가 로그인은 했지만, ADMIN 등급의 리소스에 접근하는 경우

## 404 Not Found
요청 리소스를 찾을 수 없음
- 주요청 리소스가 서버에 없음
- 또는 클라이언트가 권한이 부족한 리소스에 접근할 때, 해당 리소스를 숨기고 싶을 때

# 5xx - 서버 오류
- 서버 문제로 오류 발생
- 서버에 문제가 있기 때문에 재시도 하면 성공할 수도 있음 (복구가 되거나.. 등등)

## 500 Internal Server Error
서버 문제로 오류 발생, 애매하면 500 오류
- 서버 내부 문제로 오류 발생
- 애매하면 500 오류

## 503 Service Unavailable
서비스 이용 불가
- 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없음
- Retry-After 헤더 필드로 얼마 뒤에 복구되는지 보낼 수도 있음



***
<br>

    💛 개인 공부 기록용 블로그입니다. 👻

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}