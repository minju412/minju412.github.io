---
title:  "[SPRING] 로그인 처리 - 1. 쿠키, 세션 "

categories:
  - Spring
tags:
  - [Framework, Spring, Java]

toc: true
toc_sticky: true
 
date: 2022-07-05 16:30:54
last_modified_at: 2022-07-05 16:30:58
---
이전 프로젝트에 이어서 로그인 처리 기능을 학습한다.
# package 구조
![스크린샷 2022-07-05 오후 4 56 36](https://user-images.githubusercontent.com/59405576/177278866-30b0c82a-f5e0-47bf-abe2-0b5dde129091.png)<br>
도메인이 가장 중요하다.<br>
도메인 = 화면, UI, 기술 인프라 등등의 영역은 제외한 시스템이 구현해야 하는 핵심 비즈니스 업무 영역을 말함<br><br>
향후 web을 다른 기술로 바꾸어도 도메인은 그대로 유지할 수 있어야 한다.<br>
이렇게 하려면 web은 domain을 알고있지만 domain은 web을 모르도록 설계해야 한다. <br>
📍 이것을 web은 domain을 의존하지만, domain은 web을 의존하지 않는다고 표현한다. <br><br>
예를 들어 web 패키지를 모두 삭제해도 domain에는 전혀 영향이 없도록 의존관계를 설계하는 것이 중요하다. 🌟 <br>
반대로 이야기하면 domain은 web을 참조하면 안된다.

# 회원 가입
## 🗂 domain
### `Member`
`src/main/java/hello/login/domain/member/Member.java`
```java
@Data
public class Member {

    private Long id;

    @NotEmpty
    private String loginId; // 로그인 ID
    @NotEmpty
    private String name;
    @NotEmpty
    private String password;
}
```

### `MemberRepository`
`src/main/java/hello/login/domain/member/MemberRepository.java`
```java
@Slf4j
@Repository
public class MemberRepository {

    private static Map<Long, Member> store = new HashMap<>(); // static 사용
    private static long sequence = 0L; // static 사용

    public Member save(Member member){
        member.setId(++sequence);
        log.info("save: member={}", member);
        store.put(member.getId(), member);
        return member;
    }

    public Member findById(Long id){
        return store.get(id);
    }

    public Optional<Member> findByLoginId(String loginId){
        return findAll().stream()
                .filter(m -> m.getLoginId().equals(loginId))
                .findFirst();
    }

    public List<Member> findAll(){
        return new ArrayList<>(store.values());
    }

    public void clearStore(){
        store.clear();
    }
}
```

## 🗂 web
### `MemberController`
`src/main/java/hello/login/web/member/MemberController.java`
```java
@Controller
@RequiredArgsConstructor
@RequestMapping("/members")
public class MemberController {

    private final MemberRepository memberRepository;

    @GetMapping("/add")
    public String addForm(@ModelAttribute("member") Member member){
        return "members/addMemberForm";
    }

    @PostMapping("/add")
    public String save(@Valid @ModelAttribute Member member, BindingResult bindingResult){
        if(bindingResult.hasErrors()){
            return "members/addMemberForm";
        }

        memberRepository.save(member);
        return "redirect:/";
    }
}
```
`@ModelAttribute("member")` 를 `@ModelAttribute` 로 변경해도 결과는 같다. 여기서는 IDE에서 인식 문제가 있어서 적용했다.

## 🗂 뷰 템플릿 
### `addMemberForm`
`src/main/resources/templates/members/addMemberForm.html`
```html
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="utf-8">
    <link th:href="@{/css/bootstrap.min.css}"
          href="../css/bootstrap.min.css" rel="stylesheet">
    <style>
        .container {
            max-width: 560px;
        }
        .field-error {
            border-color: #dc3545;
            color: #dc3545;
        }
    </style>
</head>
<body>

<div class="container">

    <div class="py-5 text-center">
        <h2>회원 가입</h2>
    </div>

    <h4 class="mb-3">회원 정보 입력</h4>

    <form action="" th:action th:object="${member}" method="post">

        <div th:if="${#fields.hasGlobalErrors()}">
            <p class="field-error" th:each="err : ${#fields.globalErrors()}" th:text="${err}">전체 오류 메시지</p>
        </div>

        <div>
            <label for="loginId">로그인 ID</label>
            <input type="text" id="loginId" th:field="*{loginId}" class="form-control"
                   th:errorclass="field-error">
            <div class="field-error" th:errors="*{loginId}" />
        </div>
        <div>
            <label for="password">비밀번호</label>
            <input type="password" id="password" th:field="*{password}" class="form-control"
                   th:errorclass="field-error">
            <div class="field-error" th:errors="*{password}" />
        </div>
        <div>
            <label for="name">이름</label>
            <input type="text" id="name" th:field="*{name}" class="form-control"
                   th:errorclass="field-error">
            <div class="field-error" th:errors="*{name}" />
        </div>


        <hr class="my-4">

        <div class="row">
            <div class="col">
                <button class="w-100 btn btn-primary btn-lg" type="submit">회원 가입</button>
            </div>
            <div class="col">
                <button class="w-100 btn btn-secondary btn-lg" onclick="location.href='items.html'"
                        th:onclick="|location.href='@{/}'|"
                        type="button">취소</button>
            </div>
        </div>

    </form>

</div> <!-- /container -->
</body>
</html>
```

# 로그인 기능
## 🗂 domain
### `LoginService`
`src/main/java/hello/login/domain/login/LoginService.java`
```java
@Service
@RequiredArgsConstructor
public class LoginService {

    private final MemberRepository memberRepository;

    /**
     * @return null 이면 로그인 실패
     */
    public Member login(String loginId, String password){
        return memberRepository.findByLoginId(loginId)
                .filter(m -> m.getPassword().equals(password))
                .orElse(null);
    }
}
```
`LoginService`는 로그인의 핵심 비즈니스 로직이다. <br>
회원을 조회한 다음에 파라미터로 넘어온 password와 비교해서 같으면 회원을 반환하고, 만약 password가 다르면 `null` 을 반환한다.

## 🗂 web
### `LoginForm`
`src/main/java/hello/login/web/login/LoginForm.java`
```java
@Data
public class LoginForm {

    @NotEmpty
    private String loginId;

    @NotEmpty
    private String password;
}
```

### `LoginController`
`src/main/java/hello/login/web/login/LoginController.java`
```java
@Slf4j
@Controller
@RequiredArgsConstructor
public class LoginController {

    private final LoginService loginService;

    @GetMapping("/login")
    public String loginForm(@ModelAttribute("loginForm") LoginForm form) {
        return "login/loginForm";
    }

    @PostMapping("/login")
    public String login(@Valid @ModelAttribute LoginForm form, BindingResult bindingResult){
        if(bindingResult.hasErrors()){
            return "login/loginForm";
        }

        Member loginMember = loginService.login(form.getLoginId(), form.getPassword());

        if(loginMember==null){
            bindingResult.reject("loginFail", "아이디 또는 비밀번호가 맞지 않습니다.");
            return "login/loginForm";
        }

        // 로그인 성공 처리 TODO

        return "redirect:/";
    }
}
```
로그인 컨트롤러는 로그인 서비스를 호출해서 로그인에 성공하면 홈 화면으로 이동하고, 로그인에 실패하면 `bindingResult.reject()` 를 사용해서 글로벌 오류( `ObjectError` )를 생성한다. <br>
그리고 정보를 다시 입력하도록 로그인 폼을 뷰 템플릿으로 사용한다.



## 🗂 뷰 템플릿 
### `loginForm`
`src/main/resources/templates/login/loginForm.html`
```html
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="utf-8">
    <link th:href="@{/css/bootstrap.min.css}"
          href="../css/bootstrap.min.css" rel="stylesheet">
    <style>
        .container {
            max-width: 560px;
        }
        .field-error {
            border-color: #dc3545;
            color: #dc3545;
        }
    </style>
</head>
<body>

<div class="container">

    <div class="py-5 text-center">
        <h2>로그인</h2>
    </div>

    <form action="item.html" th:action th:object="${loginForm}" method="post">

        <div th:if="${#fields.hasGlobalErrors()}">
            <p class="field-error" th:each="err : ${#fields.globalErrors()}" th:text="${err}">전체 오류 메시지</p>
        </div>

        <div>
            <label for="loginId">로그인 ID</label>
            <input type="text" id="loginId" th:field="*{loginId}" class="form-control"
                   th:errorclass="field-error">
            <div class="field-error" th:errors="*{loginId}" />
        </div>
        <div>
            <label for="password">비밀번호</label>
            <input type="password" id="password" th:field="*{password}" class="form-control"
                   th:errorclass="field-error">
            <div class="field-error" th:errors="*{password}" />
        </div>

        <hr class="my-4">

        <div class="row">
            <div class="col">
                <button class="w-100 btn btn-primary btn-lg" type="submit">로그인</button>
            </div>
            <div class="col">
                <button class="w-100 btn btn-secondary btn-lg" onclick="location.href='items.html'"
                        th:onclick="|location.href='@{/}'|"
                        type="button">취소</button>
            </div>
        </div>

    </form>

</div> <!-- /container -->
</body>
</html>
```
로그인 폼 뷰 템플릿에는 특별한 코드는 없다. `loginId` , `password` 가 틀리면 글로벌 오류가 나타난다.<br><br>
그런데 아직 로그인이 되면 홈 화면에 고객 이름이 보여야 한다는 요구사항을 만족하지 못한다. <br>
로그인의 상태를 유지하면서, 로그인에 성공한 사용자는 홈 화면에 접근시 고객의 이름을 보여주려면 어떻게 해야할까?

# 로그인 처리하기 - 쿠키 사용
쿠키를 사용해서 로그인, 로그아웃 기능을 구현해보자.

## 쿠키
서버에서 로그인에 성공하면 HTTP 응답에 쿠키를 담아서 브라우저에 전달하자. <br>
그러면 브라우저는 앞으로 해당 쿠키를 지속해서 보내준다.<br><br>
쿠키에는 영속 쿠키와 세션 쿠키가 있다.
- 영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유지
- 세션 쿠키: 만료 날짜를 생략하면 브라우저 종료시 까지만 유지

브라우저 종료시 로그아웃이 되길 기대하므로, 우리에게 필요한 것은 세션 쿠키이다.

## 로그인 기능

### 🗂 web
#### `LoginController`
##### `login()`
`src/main/java/hello/login/web/login/LoginController.java`
```java
@Slf4j
@Controller
@RequiredArgsConstructor
public class LoginController {

    private final LoginService loginService;

    @PostMapping("/login")
    public String login(@Valid @ModelAttribute LoginForm form, BindingResult bindingResult, HttpServletResponse res){
        if(bindingResult.hasErrors()){
            return "login/loginForm";
        }

        Member loginMember = loginService.login(form.getLoginId(), form.getPassword());

        if(loginMember==null){
            bindingResult.reject("loginFail", "아이디 또는 비밀번호가 맞지 않습니다.");
            return "login/loginForm";
        }

        // 로그인 성공 처리
        // 🌟 쿠키에 시간 정보를 주지 않으면 세션 쿠키 (브라우저 종료 시 모두 종료)
        Cookie idCookie = new Cookie("memberId", String.valueOf(loginMember.getId()));
        res.addCookie(idCookie);

        return "redirect:/";
    }
}
```

##### 쿠키 생성 로직
```java
Cookie idCookie = new Cookie("memberId", String.valueOf(loginMember.getId()));
res.addCookie(idCookie);
```
로그인에 성공하면 쿠키를 생성하고 `HttpServletResponse` 에 담는다. <br>
쿠키 이름은 `memberId` 이고, 값은 회원의 `id`를 담아둔다.<br>
웹브라우저는 종료 전까지 회원의 `id`를 서버에 계속 보내줄 것이다.

#### `HomeController` - 로그인 처리
이제 요구사항에 맞추어 로그인에 성공하면 로그인 한 사용자 전용 홈 화면을 보여주자.<br>
`src/main/java/hello/login/web/HomeController.java`
```java
@Slf4j
@Controller
@RequiredArgsConstructor
public class HomeController {

    private final MemberRepository memberRepository;

    @GetMapping("/")
    public String homeLogin(@CookieValue(name = "memberId", required = false) Long memberId, Model model){

        if(memberId == null){
            return "home";
        }

        // 로그인
        Member loginMember = memberRepository.findById(memberId);
        if(loginMember == null){
            return "home";
        }

        model.addAttribute("member", loginMember);
        return "loginHome";
    }
}
```
- `@CookieValue` 를 사용하면 편리하게 쿠키를 조회할 수 있다.
- 로그인 하지 않은 사용자도 홈에 접근할 수 있기 때문에 `required = false` 를 사용한다.

로직 분석
- 로그인 쿠키( `memberId` )가 없는 사용자는 기존 home 으로 보낸다. 추가로 로그인 쿠키가 있어도 회원이 없으면 `home` 으로 보낸다.
- 로그인 쿠키( `memberId` )가 있는 사용자는 로그인 사용자 전용 홈 화면인 `loginHome` 으로 보낸다. 추가로 홈 화면에 화원 관련 정보도 출력해야 해서 `member` 데이터도 모델에 담아서 전달한다.

### 🗂 뷰 템플릿
#### `loginHome` - 로그인 사용자 전용
`src/main/resources/templates/loginHome.html`
```html
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="utf-8">
    <link th:href="@{/css/bootstrap.min.css}"
          href="../css/bootstrap.min.css" rel="stylesheet">
</head>
<body>

<div class="container" style="max-width: 600px">
    <div class="py-5 text-center">
        <h2>홈 화면</h2>
    </div>

    <h4 class="mb-3" th:text="|로그인: ${member.name}|">로그인 사용자 이름</h4>

    <hr class="my-4">

    <div class="row">
        <div class="col">
            <button class="w-100 btn btn-secondary btn-lg" type="button"
                    th:onclick="|location.href='@{/items}'|">
                상품 관리
            </button>
        </div>
        <div class="col">
            <form th:action="@{/logout}" method="post">
                <button class="w-100 btn btn-dark btn-lg" onclick="location.href='items.html'" type="submit">
                    로그아웃
                </button>
            </form>
        </div>
    </div>

    <hr class="my-4">

</div> <!-- /container -->

</body>
</html>
```
- `th:text="|로그인: ${member.name}|"` : 로그인에 성공한 사용자 이름을 출력한다. 
- 상품 관리, 로그아웃 버튼을 노출한다.

## 로그아웃 기능
이번에는 로그아웃 기능을 만들어보자. 로그아웃 방법은 다음과 같다. 
- 세션 쿠키이므로 웹 브라우저 종료시
- 서버에서 해당 쿠키의 종료 날짜를 0으로 지정

### 🗂 web
#### `LoginController`
##### `logout()`
`src/main/java/hello/login/web/login/LoginController.java`
```java
@Slf4j
@Controller
@RequiredArgsConstructor
public class LoginController {
    ...
    @PostMapping("/logout")
    public String logout(HttpServletResponse res){
        expireCookie(res, "memberId");
        return "redirect:/";
    }

    private void expireCookie(HttpServletResponse res, String cookieName) {
        Cookie cookie = new Cookie(cookieName, null);
        cookie.setMaxAge(0);
        res.addCookie(cookie);
    }
}
```
로그아웃도 응답 쿠키를 생성하는데 `Max-Age=0` 를 확인할 수 있다. 해당 쿠키는 즉시 종료된다.

# 쿠키와 보안 문제
쿠키를 사용해서 로그인Id를 전달해서 로그인을 유지할 수 있었다. 그런데 여기에는 심각한 보안 문제가 있다.

## 보안 문제
- 쿠키 값은 임의로 변경할 수 있다.<br>
• 클라이언트가 쿠키를 강제로 변경하면 다른 사용자가 된다.<br>
• 실제 웹브라우저 개발자모드 -> Application -> Cookie 변경으로 확인<br>
• `Cookie: memberId=1` -> `Cookie: memberId=2` (다른 사용자의 이름이 보임) 

- 쿠키에 보관된 정보는 훔쳐갈 수 있다.<br>
• 만약 쿠키에 개인정보나, 신용카드 정보가 있다면?<br>
• 이 정보가 웹 브라우저에도 보관되고, 네트워크 요청마다 계속 클라이언트에서 서버로 전달된다. <br>
• 쿠키의 정보가 나의 로컬 PC가 털릴 수도 있고, 네트워크 전송 구간에서 털릴 수도 있다.

- 해커가 쿠키를 한번 훔쳐가면 평생 사용할 수 있다.<br>
• 해커가 쿠키를 훔쳐가서 그 쿠키로 악의적인 요청을 계속 시도할 수 있다.

## 대안
- 쿠키에 중요한 값을 노출하지 않고, 사용자 별로 예측 불가능한 임의의 토큰(랜덤 값)을 노출하고, 서버에서 토큰과 사용자 id를 매핑해서 인식한다. <br>
그리고 서버에서 토큰을 관리한다.
- 토큰은 해커가 임의의 값을 넣어도 찾을 수 없도록 예상 불가능 해야 한다.
- 해커가 토큰을 털어가도 시간이 지나면 사용할 수 없도록 서버에서 해당 토큰의 만료시간을 짧게(예: 30분) 유지한다. <br>
또는 해킹이 의심되는 경우 서버에서 해당 토큰을 강제로 제거하면 된다.

# 로그인 처리하기 
앞서 쿠키에 중요한 정보를 보관하는 방법은 여러가지 보안 이슈가 있었다. <br><br>
이 문제를 해결하려면 결국 중요한 정보를 모두 서버에 저장해야 한다. <br>
그리고 클라이언트와 서버는 추정 불가능한 임의의 식별자 값으로 연결해야 한다.<br><br>
이렇게 서버에 중요한 정보를 보관하고 연결을 유지하는 방법을 세션이라 한다.<br>
세션을 어떻게 개발할지 먼저 개념을 이해해보자.
## 1. 세션 동작 방식
### 1) 로그인
![스크린샷 2022-07-06 오전 12 20 30](https://user-images.githubusercontent.com/59405576/177361955-dddc2417-24dc-4ea5-b429-069ae34a55b0.png)
- 사용자가 `loginId` , `password` 정보를 전달하면 서버에서 해당 사용자가 맞는지 확인한다.

### 2) 세션 생성
![스크린샷 2022-07-06 오전 12 20 44](https://user-images.githubusercontent.com/59405576/177362001-8a44a5f1-5475-4a42-ab3f-d52cc34bcb92.png)
- 세션 ID를 생성하는데, 추정 불가능해야 한다. 
- UUID는 추정이 불가능하다.<br>- `Cookie: mySessionId=zz0101xx-bab9-4b92-9b32-dadb280f4b61`
- 생성된 세션 ID와 세션에 보관할 값( `memberA` )을 서버의 세션 저장소에 보관한다.

### 3) 세션 id를 응답 쿠키로 전달
![스크린샷 2022-07-06 오전 12 20 58](https://user-images.githubusercontent.com/59405576/177362034-3ba63e11-bc91-4ad3-8bfe-e1c60b14af11.png)<br>
클라이언트와 서버는 결국 쿠키로 연결이 되어야 한다.
- 서버는 클라이언트에 `mySessionId` 라는 이름으로 세션ID 만 쿠키에 담아서 전달한다. 
- 클라이언트는 쿠키 저장소에 `mySessionId` 쿠키를 보관한다.<br><br>

🌟 중요<br>
- 여기서 중요한 포인트는 회원과 관련된 정보는 전혀 클라이언트에 전달하지 않는다는 것이다. 
- 오직 추정 불가능한 세션 ID만 쿠키를 통해 클라이언트에 전달한다.

### 4) 클라이언트의 세션 id 쿠키 전달 - 로그인 이후 접근
![스크린샷 2022-07-06 오전 12 21 09](https://user-images.githubusercontent.com/59405576/177362083-c0475ad5-bd6e-41e0-ba4d-b9a1b1695e3c.png)
- 클라이언트는 요청시 항상 `mySessionId` 쿠키를 전달한다.
- 서버에서는 클라이언트가 전달한 `mySessionId` 쿠키 정보로 세션 저장소를 조회해서 로그인시 보관한 세션 정보를 사용한다.

### 정리
세션을 사용해서 서버에서 중요한 정보를 관리하게 되었다. 덕분에 다음과 같은 보안 문제들을 해결할 수 있다.
- 쿠키 값을 변조 가능 -> 예상 불가능한 복잡한 세션Id를 사용한다.
- 쿠키에 보관하는 정보는 클라이언트 해킹시 털릴 가능성이 있다. -> 세션Id가 털려도 여기에는 중요한 정보가 없다.
- 쿠키 탈취 후 사용 -> 해커가 토큰을 털어가도 시간이 지나면 사용할 수 없도록 서버에서 세션의 만료시간을 짧게(예: 30분) 유지한다. <br>
또는 해킹이 의심되는 경우 서버에서 해당 세션을 강제로 제거하면 된다.

## 2. 서블릿 HTTP 세션 - 1
서블릿은 세션을 위해 `HttpSession` 이라는 기능을 제공한다.

### HttpSession 소개
서블릿을 통해 `HttpSession` 을 생성하면 다음과 같은 쿠키를 생성한다. <br>
`Cookie: JSESSIONID=5B78E23B513F50164D6FDD8C97B0AD05`<br>
쿠키 이름이 JSESSIONID 이고, 값은 추정 불가능한 랜덤 값이다.<br><br>
서블릿이 제공하는 `HttpSession` 을 사용하도록 개발해보자.

### 🗂 web
#### `SessionConst`
`src/main/java/hello/login/web/SessionConst.java`
```java
public interface SessionConst {
    String LOGIN_MEMBER = "loginMember";
}
```
`HttpSession` 에 데이터를 보관하고 조회할 때, 같은 이름이 중복 되어 사용되므로, 상수를 하나 정의했다.

#### `LoginController`
`src/main/java/hello/login/web/login/LoginController.java`
##### `login()` & `logout()`
```java
@Slf4j
@Controller
@RequiredArgsConstructor
public class LoginController {

    private final LoginService loginService;

    @PostMapping("/login")
    public String loginV3(@Valid @ModelAttribute LoginForm form, BindingResult bindingResult, HttpServletRequest req){
        if(bindingResult.hasErrors()){
            return "login/loginForm";
        }

        Member loginMember = loginService.login(form.getLoginId(), form.getPassword());

        if(loginMember==null){
            bindingResult.reject("loginFail", "아이디 또는 비밀번호가 맞지 않습니다.");
            return "login/loginForm";
        }

        // 로그인 성공 처리
        HttpSession session = req.getSession();  // 세션이 있으면 있는 세션을 반환, 없으면 신규 세션을 생성해서 반환
        session.setAttribute(SessionConst.LOGIN_MEMBER, loginMember); // 세션에 로그인 회원 정보 보관

        return "redirect:/";
    }

    @PostMapping("/logout")
    public String logoutV3(HttpServletRequest req){
        HttpSession session = req.getSession(false);
        if(session!=null){
            session.invalidate(); // 세션을 제거한다.
        }
        return "redirect:/";
    }
}
```

###### 세션 생성과 조회
세션을 생성하려면 `request.getSession(true)` 를 사용하면 된다. <br>
`public HttpSession getSession(boolean create);`<br><br>
세션의 `create` 옵션에 대해 알아보자. 
- `request.getSession(true)`<br>- 세션이 있으면 기존 세션을 반환한다.<br>- 세션이 없으면 새로운 세션을 생성해서 반환한다. 
- `request.getSession(false)`<br>- 세션이 있으면 기존 세션을 반환한다.<br>- 세션이 없으면 새로운 세션을 생성하지 않는다. `null` 을 반환한다.
- `request.getSession()` : 신규 세션을 생성하는 `request.getSession(true)` 와 동일하다. <br>- 옵션이 없을 때, default 값이 `true` 이다.

###### 세션에 로그인 회원 정보 보관
`session.setAttribute(SessionConst.LOGIN_MEMBER, loginMember);`<br>
세션에 데이터를 보관하는 방법은 `request.setAttribute(..)` 와 비슷하다. <br>
하나의 세션에 여러 값을 저장할 수 있다.

#### `HomeController` 
`src/main/java/hello/login/web/HomeController.java`
```java
@Slf4j
@Controller
@RequiredArgsConstructor
public class HomeController {

    private final MemberRepository memberRepository;

    @GetMapping("/")
    public String homeLoginV3(HttpServletRequest req, Model model){

        HttpSession session = req.getSession(false);
        if(session == null){
            return "home";
        }

        Member loginMember = (Member)session.getAttribute(SessionConst.LOGIN_MEMBER);

        // 세션에 회원 데이터가 없으면 home
        if(loginMember == null){
            return "home";
        }

        // 세션이 유지되면 로그인으로 이동
        model.addAttribute("member", loginMember);
        return "loginHome";
    }
}
```
- `request.getSession(false)` : `request.getSession()` 를 사용하면 기본 값이 `create: true` 이므로, 로그인 하지 않을 사용자도 의미없는 세션이 만들어진다. <br>
따라서 세션을 찾아서 사용하는 시점에는 `create: false` 옵션을 사용해서 세션을 생성하지 않아야 한다.
- `session.getAttribute(SessionConst.LOGIN_MEMBER)` : 로그인 시점에 세션에 보관한 회원 객체를 찾는다.

## 3. 서블릿 HTTP 세션 - 2






















***
<br>

    💛 개인 공부 기록용 블로그입니다. 👻

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}