---
title:  "[CS50] 배열: 컴파일링 "
# excerpt: "sprintf에 대해 알아보자"

categories:
  - CS50
tags:
  - [CS50]

toc: true
toc_sticky: true
 
date: 2023-06-18 20:59:09
last_modified_at: 2023-06-18 20:59:11
---


_❄️ David Malan 교수의 [모두를 위한 컴퓨터 과학(CS50 2019)](https://www.boostcourse.org/cs112/lecture/119003?isDesc=false)을 바탕으로 정리한 내용입니다._

<br>

컴파일은 소스 코드를 오브젝트 코드로 변환시키는 과정입니다.<br>
여기서 소스 코드는 여러분이 C언어와 같은 프로그래밍 언어로 작성한 코드이고,<br>
오브젝트 코드는 기계어라고도 알려져 있는데, 0과 1로 이루어져 있으며 컴퓨터에게 프로그램이 어떻게 실행되어야 하는지 알려주는 코드입니다.<br>
make 명령어 자체는 컴파일러가 아니고 clang 이라는 컴파일러를 호출해서 C 소스 코드를 오브젝트 코드로 컴파일 하도록 합니다.

아래 코드를 살펴봅시다.
```c
#include <stdio.h>

int main(void)
{
  printf("hello, world\n");
}
```
우선 main이라는 함수가 있습니다. <br>
프로그램의 시작점으로써 실행 버튼을 클릭하는 것과 같습니다.<br><br>
printf는 출력을 담당하는 함수입니다.<br>
printf 함수를 사용하기 위해서는 stdio.h 라이브러리가 필요합니다.<br><br>
정확히 말하면 stdio.h는 헤더 파일로 C언어로 작성되어 있으며 파일명이 .h로 끝나는 파일입니다.<br>
이 파일에는 printf 함수의 프로토타입이 있어서 Clang 컴파일러가 프로그램을 컴파일할때 printf가 무엇인지 알려주는 역할을 합니다.<br><br>
코드를 clang hello.c로 컴파일하고 ./a.out 명령으로 프로그램을 실행할 때 이 과정은 컴퓨터가 이해하는 0과 1로 가득찬 파일 a.out을 생성하여 실행 가능하게 합니다.<br>
이해하기 어려운 이 과정에 대한 이해는 잠시 미뤄두고 우선 넘어가보도록 하겠습니다.<br><br>
만약 a.out과 다른 이름(hello)으로 컴파일을 하고 싶다면 아래와 같이 명령행 인자를 추가해야줘야 합니다.
```bash
$ clang -o hello hello.c
```

make 프로그램을 이용하면 이 모든 컴파일 과정을 자동으로 처리할 수 있습니다.<br>
make나 clang을 사용해서 프로그램을 실행할 때 아래 네 개의 단계를 거칩니다.<br>
![스크린샷 2023-06-18 오후 10 42 00](https://github.com/minju412/jenkins-test/assets/59405576/5bb12496-7ffd-41c1-8906-d2612c3ccf5b)<br><br>
우리가 명령어를 실행할 때 정확히 어떤 일이 일어나는지 알아보도록 하겠습니다.

## 전처리(Precompile)
컴파일의 전체 과정은 네 단계로 나누어볼 수 있습니다. <br>
그 중 첫 번째 단계는 전처리인데, 전처리기에 의해 수행됩니다. <br>
`#` 으로 시작되는 C 소스 코드는 전처리기에게 실질적인 컴파일이 이루어지기 전에 무언가를 실행하라고 알려줍니다.<br><br>
예를 들어, `#include`는 전처리기에게 다른 파일의 내용을 포함시키라고 알려줍니다. <br>
프로그램의 소스 코드에 `#include` 와 같은 줄을 포함하면, 전처리기는 새로운 파일을 생성하는데 이 파일은 여전히 C 소스 코드 형태이며 🌟 stdio.h 파일의 내용이 `#include` 부분에 포함됩니다.<br><br>
전처리 전
```c
#include <cs50.h> // ✅
#include <stdio.h> // ✅

int main(void)
{
  string name = get_string("What's your name?\n");
  printf("hello, %s\n", name);
}
```

clang이 cs50.h 와 stdio.h 파일에 직접 들어가 해당되는 코드를 가져와서 hello.c 라는 여러분의 파일에 붙여넣는 것이죠.<br><br>
전처리 후
```c
string get_string(string prompt); // ✅
int printf(string format, ...); // ✅

int main(void)
{
  string name = get_string("What's your name?\n");
  printf("hello, %s\n", name);
}
```

## 컴파일(Compile)
전처리기가 전처리한 소스 코드를 생성하고 나면 그 다음 단계는 컴파일입니다. <br>
컴파일러라고 불리는 프로그램은 C 코드를 어셈블리어라는 저수준 프로그래밍 언어로 컴파일합니다.<br><br>
어셈블리는 C보다 연산의 종류가 훨씬 적지만, 여러 연산들이 함께 사용되면 C에서 할 수 있는 모든 것들을 수행할 수 있습니다. <br><br>
🌟 "C 코드를 어셈블리 코드로 변환"시켜줌으로써 컴파일러는 컴퓨터가 이해할 수 있는 언어와 최대한 가까운 프로그램으로 만들어 줍니다. <br><br>
컴파일이라는 용어는 소스 코드에서 오브젝트 코드로 변환하는 전체 과정을 통틀어 일컫기도 하지만, 구체적으로 전처리한 소스 코드를 어셈블리 코드로 변환시키는 단계를 말하기도 합니다.

## 어셈블(Assemble)
소스 코드가 어셈블리 코드로 변환되면, 다음 단계인 어셈블 단계로 🌟 "어셈블리 코드를 오브젝트 코드"로 변환시키는 것입니다. <br><br>
컴퓨터의 중앙처리장치가 프로그램을 어떻게 수행해야 하는지 알 수 있는 명령어 형태인 연속된 0과 1들로 바꿔주는 작업이죠. <br><br>
이 변환작업은 어셈블러라는 프로그램이 수행합니다. <br>
소스 코드에서 오브젝트 코드로 컴파일 되어야 할 파일이 딱 한 개라면, 컴파일 작업은 여기서 끝이 납니다. <br>
그러나 그렇지 않은 경우에는 링크라 불리는 단계가 추가됩니다.

## 링크(Link)
만약 프로그램이 (math.h나 cs50.h와 같은 라이브러리를 포함해) 여러 개의 파일로 이루어져 있어 하나의 오브젝트 파일로 합쳐져야 한다면 링크라는 컴파일의 마지막 단계가 필요합니다. <br><br>
링커는 🌟 "여러 개의 다른 오브젝트 코드 파일을 실행 가능한 하나의 오브젝트 코드 파일로" 합쳐줍니다. <br><br>
예를 들어, 컴파일을 하는 동안에 CS50 라이브러리를 링크하면 오브젝트 코드는 GetInt()나 GetString() 같은 함수를 어떻게 실행할 지 알 수 있게 됩니다.<br><br>
이 네 단계를 거치면 최종적으로 실행 가능한 파일이 완성됩니다.


## 생각해보기
만약 컴파일링 과정을 거치지 않기 위해 바로 머신코드로 우리가 원하는 프로그램을 작성하려고 한다면 어떤 문제가 있을까요?
1. 0과 1로만 표현하기 위해서는 코드의 양이 매우 많아지게 됩니다.
2. 사용하고자 하는 코드에 대해서 가독성이 떨어지게 됩니다.
3. 개발에 필요한 시간이 증가합니다.




***
<br>


    💛 개인 공부 기록용 블로그입니다. 👻

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}