---
title:  "[E-commerce App] Docker Container를 이용한 애플리케이션 배포 "

categories:
  - SpringCloud
tags:
  - [SpringCloud]

toc: true
toc_sticky: true
 
date: 2022-10-17 15:01:01
last_modified_at: 2022-10-17 15:01:04
---

# 개요
## Running Microservices
마이크로 서비스를 운영하는 방식에는 아래 보이는 여섯가지가 있다.<br>
![스크린샷 2022-10-17 오후 3 02 35](https://user-images.githubusercontent.com/59405576/196101121-a8fb6812-f2e7-48a9-9acc-fc192a3b63e5.png){: width="800" height="800"}<br><br>
이 중에서, 이번 글에서는 [Docker + Local]을 다뤄볼 것이다.<br>
나중에 다른 환경에 배포한다고 해도, Docker 이미지를 그대로 컨테이너화 시켜 사용할 수 있다.

## Running Microservices in Local
![스크린샷 2022-10-17 오후 3 15 29](https://user-images.githubusercontent.com/59405576/196102322-f4541eb1-78f9-430d-a006-25a87a556bec.png){: width="800" height="800"}<br>
지금까지 꽤 많은 마이크로 서비스들을 개발했다.<br>
이번에는 해당하는 마이크로 서비스들을 이미지로 만들 것이고, 회색으로 보이는 서비스들에 대해서도 도커 컨테이너 환경에서 구동해 볼 것이다.<br><br>
그 전에 다양한 서비스들이 서로 통신할 때 무리가 없도록 하나의 가상의 네트워크를 가질 수 있도록 구축하자.

# Docker Container
## Create Bridge Network
- Bridge network<br>호스트 pc와 별도의 가상의 네트워크를 만들고, 그 가상의 네트워크에서 컨테이너들을 배치해 사용하는 방식이다.
```bash
$ docker network create --driver bridge [브릿지 이름]
```
- Host network<br>- 네트워크를 호스트로 설정하면 호스트의 네트워크 환경을 그대로 사용<br>- 포트 포워딩 없이 내부 어플리케이션 사용
- None network<br>- 네트워크를 사용하지 않음<br>- Io 네트워크만 사용, 외부와 단절

이제 터미널로 네트워크를 생성해보자.<br><br>
그 전에 불필요한 리소스(중지되어있는 컨테이너, 사용되고 있지 않은 네트워크, 이전단계의 이미지와 캐시되어 있는 값)를 모두 삭제하는 커맨드를 통해 삭제하고 진행하자.
```bash
$ docker system prune
```
<img width="512" alt="스크린샷 2022-10-17 오후 3 32 52" src="https://user-images.githubusercontent.com/59405576/196105014-88b33fa4-05fd-4b37-bd1c-19d5416df2e7.png"><br>

이제 네트워크를 확인해보면, 기본적으로 제공되는 세 가지 네트워크(bridge, host, null)가 존재할 것이다.
```bash
$ docker network ls
```
<img width="483" alt="스크린샷 2022-10-17 오후 3 34 00" src="https://user-images.githubusercontent.com/59405576/196105228-ab3b1cd3-52b2-4cd3-8a5b-0d6e812615cd.png"><br>

이제 네트워크를 생성해보자.
```bash
# 네트워크 생성
$ docker network create --gateway 172.18.0.1 --subnet 172.18.0.0/16 ecommerce-network

# 네트워크 목록 확인
docker network ls

# 특정 네트워크 상세 보기
$ docker network inspect ecommerce-network
```
<img width="951" alt="스크린샷 2022-10-17 오후 3 40 25" src="https://user-images.githubusercontent.com/59405576/196106499-e24d9754-5ca0-4a2c-9e2a-c508a0d33c38.png"><br>
게이트웨이(`--gateway 172.18.0.1`)와 서브넷 마스크(`--subnet 172.18.0.0/16`)를 지정하지 않고 만들 수도 있지만,<br>
그랬을 때는, 자동으로 컨테이너의 ip가 할당되게 하는 옵션 말고 <br>
직접 ip address를 지정해서 컨테이너를 띄울 수도 있는데, 이 경우에 오류가 발생할 수 있다.<br><br>
`docker network inspect ecommerce-network` 커맨듣로 방금 생성한 네트워크를 확인해보면, <br>
subnet과 gateway가 지정되었음을 알 수 있고, 현재 해당 네트워크에 추가되어진 컨테이너가 아무것도 없음을 확인할 수 있다.<br><br>
이런식으로 네트워크를 직접 생성해서 사용하게 되면 좋은 점은,<br>
일반적인 컨테이너들끼리는 IP Address를 이용해 통신을 하게 되는데,<br>
같은 네트워크에 포함되어있는 컨테이너들끼리는 IP Address 외에도, 컨테이너 ID 혹은 이름을 이용해 통신할 수 있다.<br><br>
이것이 장점인 이유는, 도커 컨테이너를 생성할 때에는 비어있는 IP부터 순차적으로 할당되기 때문에<br>
어떤 환경에서 각각의 마이크로 서비스들이 배포되었을 때 IP Address가 유동적으로 변경될 수 있고,<br>
IP Address로만 통신을 하게 되면, 변경된 IP에 따라 다른 서비스들에 각각 다시 설정을 해주어야하는 불편함이 있기 때문이다.<br><br>
이 때, `--name` 옵션을 통해 지정한 컨테이너의 이름을 이용해 통신하게 되면, <br>
IP Address가 변경되더라도 다른 쪽에 있는 마이크로 서비스 혹은 서버들에는 변경 사항이 없을 것이다.<br>
![스크린샷 2022-10-17 오후 3 53 02](https://user-images.githubusercontent.com/59405576/196108626-639a996a-3b73-4176-9e5e-95d3b2bc18ea.png){: width="700" height="700"}

## 1. RabbitMQ
> [https://rabbitmq.com/](https://rabbitmq.com/)

도커 컨테이너로 변환시킬 첫 번째 항목은 configuration service 이다.<br>
그런데, configuration service에서 변경된 설정 파일의 내용을 모든 마이크로 서비스들에게 한꺼번에 업데이트 시켜주기 위해 사용했던 것이 Spring Cloud Bus 였다.<br>
Spring Cloud Bus 에서 사용할 수 있는 messaging queueing server로써 RabbitMQ를 사용했다.<br><br>
기존에는 RabbitMQ를 로컬에 직접 설치헤서 사용했다면, 이를 도커 컨테이너화 시켜서 기동해보자.<br><br>
위 레빗엠큐 공식 홈페이지에 접속해 [Get Started] > [Download + Installation]를 클릭하자.<br>
그리고 아래로 내리다보면 레빗엠큐를 도커로 어떻게 설치하면 좋은지` 나와있다.<br>
![스크린샷 2022-10-17 오후 4 09 57](https://user-images.githubusercontent.com/59405576/196111469-53b0b2d8-c4c5-490c-b745-d61a145b6f0f.png)<br>
헤딩 링크를 클릭하게 되면 도커 허브 사이트로 이동하는데, 여기서 사용하고자하는 태그를 선택해 이미지를 pull 받을 수 있다.
```bash
$ docker pull rabbitmq:management
```

그리고 아래와 같이 컨테이너를 생성하고 기동할 수 있다. <br>
(미리 `pull` 받지 않고 `run`만 해도 `pull`을 받아오기 때문에 나는 아래 커맨드만 실행했다.)
```bash
$ docker run -d --name rabbitmq --network ecommerce-network \
-p 15672:15672 -p 5672:5672 -p 15671:15671 -p 5671:5671 -p 4369:4369 \
-e RABBITMQ_DEFAULT_USER=guest \
-e RABBITMQ_DEFAULT_PASS=guest \
rabbitmq:management
```

### 만약 해당 포트가 이미 사용중이라면?
해당 포트를 사용 중인 프로세스를 찾아 `kill` 한 뒤에 다시 기동한다.<br>
(이 때 이미 생성된 rabbitmq 컨테이너도 삭제한 뒤에 다시 `run` 하자.)
```bash
$ sudo lsof -i tcp:4369
$ sudo kill -9 42938
```
<img width="1424" alt="스크린샷 2022-10-17 오후 4 19 55" src="https://user-images.githubusercontent.com/59405576/196113220-0d53d4fc-9336-4a92-98a8-09e476692677.png"><br><br>
그리고 rabbimq 컨테이너가 아까 생성한 `ecommerce-network`를 사용 중인지 확인해야 한다!
```bash
$ docker network inspect ecommerce-network
```
<img width="656" alt="스크린샷 2022-10-17 오후 4 33 12" src="https://user-images.githubusercontent.com/59405576/196115947-0d257119-243d-418b-8d1e-bf780a91c2d2.png"><br>
`172.18.0.2`이라는 IP Address가 할당된 것을 확인할 수 있다.<br>
앞으로 `ecommerce-network`를 사용하는 컨테이너들은 RabbitMQ 컨테이너를 호출할 때,<br>
`172.18.0.2`라는 IP Address로 호출하거나 `rabbitmq`라는 이름으로 호출할 수 있다.<br>

이제 웹 브라우저로 접속해보자.<br>
![스크린샷 2022-10-17 오후 4 38 16](https://user-images.githubusercontent.com/59405576/196116996-1a0488d3-5318-4ce6-9faf-323981c9ffb5.png)<br>
정상적으로 접속할 수 있고, username과 password는 모두 `guest`이다.<br><br>
이렇게 첫 번째로 RabbitMQ 서비스를 도커 컨테이너화 시켜서 기동해보았다.

## 2. `config-service`
이제 Configuration Service를 도커 이미지화 한 뒤, 컨테이너를 통해 기동해보자.

### Dockerfile을 통해 이미지 만들기
`config-service`를 Dockerfile을 통해 이미지화 할 수 있다.<br>
`Dockerfile`
```Dockerfile
FROM openjdk:17-ea-11-jdk-slim
VOLUME /tmp
COPY apiEncryptionKey.jks apiEncryptionKey.jks
COPY target/config-service-0.0.1-SNAPSHOT.jar ConfigService.jar
ENTRYPOINT ["java","-jar","ConfigService.jar"]
```
이 때, 중요한건 configuration server 안에 키 값이 저장되어 있었다는 것이다.<br>
(이전에 configuration server 안에 있는 민감 정보를 암호화하기 위해서 keytools를 통해 생성했었다.)<br>
이 파일 역시 컨테이너 안에 포함되어 있어야 한다.<br>
따라서 Dockerfile 안에 `COPY apiEncryptionKey.jks apiEncryptionKey.jks` 커맨드를 포함하여<br>
host에 존재하는 파일을 도커 컨테이너 안으로 복사하자.<br><br>

### `bootstrap.yml`에서 키파일 위치 변경
컨테이너에서는 더이상 키파일의 위치가 `/study/msa/...`가 아니기 때문에 아래와 같이 변경하자.
```yml
encrypt:
  key-store:
    # location: file://${user.home}/study/msa/keystore/apiEncryptionKey.jks
    location: file:/apiEncryptionKey.jks # 🌟 컨테이너 안에 복사된 키 파일의 위치로 변경
    password: test1234
    alias: apiEncryptionKey
```

그리고 지금까지는 native file repo에 있는 설정 파일(`.yml`)을 이용했는데,<br>
이제부터는 remote repository에 있는 설정 파일을 사용하자.

### 배포























***
<br>


    💛 개인 공부 기록용 블로그입니다. 👻

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}